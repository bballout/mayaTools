global proc sourceScripts (){	if(`window -q -exists sourceScriptsWin`)		deleteUI sourceScriptsWin;	window -wh 275 100 -t "Source Scripts" sourceScriptsWin; 	formLayout mainLayout;	string $homeButton = `button -l "Source Home" -w 100 -c "sourceScriptsHome" sourceHomeButton`;	string $workButton = `button -l "Source Work" -w 100 -c "sourceScriptsWork" sourceWorkButton`;	string $txt = `textField -w 200 setPathField`;	string $txtBt = `button -l "Source This" -c "sourceDefinedPath" fieldButton`;	formLayout -edit	-attachForm    $homeButton     "top"    15	-attachForm    $homeButton     "left"   15	-attachForm    $homeButton    "bottom"  55	-attachForm    $workButton     "top"   15	-attachForm $workButton       "right"  15 	-attachForm    $workButton    "bottom" 55	-attachControl $txt    "top"   15  $homeButton	-attachForm    $txt    "left"  5 	-attachControl $txt    "right" 5 $txtBt  	-attachForm    $txt   "bottom" 5	-attachControl $txtBt    "top"   15  $homeButton	-attachNone    $txtBt    "left"  	-attachForm    $txtBt    "right" 15 	-attachForm    $txtBt   "bottom" 5	 mainLayout;	showWindow sourceScriptsWin;}global proc sourceDefinedPath (){	string $text = `textField -q -text setPathField`;	string $subText = `substitute "\"" $text "/"`;	string $myScriptDir = $subText;	string $files[] = `getFileList -folder $myScriptDir -filespec "*.mel "`;	for ($file in $files)	{		string $filePath = ($myScriptDir + $file);		string $fileName = ("\"" + $filePath + "\"");		evalDeferred ("source" + $fileName);		print ("Sourced " + ($filePath + ".\n"));	}	}global proc sourceScriptsHome (){	string $myScriptDir = "C:/Users/Bill/Documents/maya/2009/prefs/scripts/";	string $files[] = `getFileList -folder $myScriptDir -filespec "*.mel "`;	for ($file in $files)	{		string $filePath = ($myScriptDir + $file);		string $fileName = ("\"" + $filePath + "\"");		evalDeferred("source" + $fileName);		print ("Sourced " + ($filePath + ".\n"));	}		string $myScriptDir = "C:/Users/Bill/Documents/maya/2009/scripts/";	string $files[] = `getFileList -folder $myScriptDir -filespec "*.mel "`;	for ($file in $files)	{		string $filePath = ($myScriptDir + $file);		string $fileName = ("\"" + $filePath + "\"");		evalDeferred("source" + $fileName);		print ("Sourced " + ($filePath + ".\n"));	}}global proc sourceScriptsWork (){	string $myScriptDir = "C:/Users/balloutb/Documents/maya/2009-x64/prefs/scripts/";	string $files[] = `getFileList -folder $myScriptDir -filespec "*.mel "`;	for ($file in $files)	{		string $filePath = ($myScriptDir + $file);		string $fileName = ("\"" + $filePath + "\"");		evalDeferred ("source" + $fileName);		print ("Sourced " + ($filePath + ".\n"));	}}global proc controlRenderVis (){	string $nurbsShapes[] = `ls -type nurbsSurface`;	for ($obj in $nurbsShapes)	{		string $control = `gmatch $obj "*_Ctrl*"`;		if($control)		{			setAttr ($obj + ".primaryVisibility") 0;			setAttr ($obj + ".castsShadows") 0;			setAttr ($obj + ".receiveShadows") 0;			setAttr ($obj + ".motionBlur") 0;			setAttr ($obj + ".smoothShading") 0;			setAttr ($obj + ".visibleInReflections") 0;			setAttr ($obj + ".visibleInRefractions") 0;			setAttr ($obj + ".miTransparencyCast") 0;			setAttr ($obj + ".miTransparencyReceive") 0;			setAttr ($obj + ".miReflectionReceive") 0;			setAttr ($obj + ".miRefractionReceive") 0;			setAttr ($obj + ".miFinalGatherCast") 0;			setAttr ($obj + ".miFinalGatherCast") 1;			setAttr ($obj + ".miFinalGatherCast") 0;			setAttr ($obj + ".miFinalGatherReceive") 0;			print ($obj + " is now invisible.\n");		}	}}global proc createGroups (string $suffix, int $freeze){		string $sel[] = `ls -sl`;				for($obj in $sel)		{				float $pos[3] = `xform -q -ws -t $obj`;			float $rot[3] = `xform -q -ws -ro $obj`;			float $rotatePivot[] = `xform -q -ws -rp $obj`;							group -n (($obj + "_") + $suffix) -r $obj;			//move -a -ws $pos[0] $pos[1] $pos[2] (($obj + "_") + $suffix);			rotate -a -ws $rot[0] $rot[1] $rot[2] (($obj + "_") + $suffix);			select $obj;						if($freeze == 1)			{				smartFreezeTransform;			}			move -a -ws $rotatePivot[0] $rotatePivot[1] $rotatePivot[2] ((($obj + "_") + $suffix) + ".scalePivot") ((($obj + "_") + $suffix) + ".rotatePivot") ;		}}global proc renameGroup (string $suffix){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		rename $target (($source + "_") +  $suffix) ; }global proc createNullPointMatch (string $suffix){	string $sel[] = `ls -sl`;		for ($obj in $sel)	{		float $pos[] = `xform -q -ws -t $obj`;		float $rot[] = `xform -q -ws -ro $obj`;				string $null = `group -em -n (($obj + "_") + $suffix)`;				move -r -ws $pos[0] $pos[1] $pos[2] $null;		rotate -r -ws $rot[0] $rot[1] $rot[2] $null;			}}global proc createAutoGroups (){		string $sel[] = `ls -sl`;		for ($obj in $sel)		{				float $pos[3] = `xform -q -ws -t $obj`;				float $rot[3] = `xform -q -ws -ro $obj`;				group -em -n ($obj + "_Auto_Rotation_Translation");				move -r -ws $pos[0] $pos[1] $pos[2] ($obj + "_Auto_Rotation_Translation");				rotate -r -ws $rot[0] $rot[1] $rot[2] ($obj + "_Auto_Rotation_Translation");		}			} 	global proc deleteConstraints (){		string $sel[] = `ls -sl`;				for ($obj in $sel)		{				if (`nodeType $obj` == "parentConstraint" || `nodeType $obj` == "pointConstraint" ||					`nodeType $obj` == "aimConstraint" || `nodeType $obj` == "orientConstraint")				{						delete $obj;				}		}}	global proc setSkinValue (){	if (`window -q -exists setSkinValueWin` == true)	{		deleteUI setSkinValueWin;	}	window -t "Set Paint Skin Value" -wh 120 90 setSkinValueWin;	columnLayout -adj true;	button -l ".001" -c "artAttrSkinPaintCtx -e -value .001 `currentCtx`";	button -l ".005" -c "artAttrSkinPaintCtx -e -value .005 `currentCtx`";	button -l ".010" -c "artAttrSkinPaintCtx -e -value .010 `currentCtx`";	button -l ".100" -c "artAttrSkinPaintCtx -e -value .100 `currentCtx`";	button -l "1.0"  -c "artAttrSkinPaintCtx -e -value  1.0 `currentCtx`";	showWindow setSkinValueWin;}		global proc ClustersRelative ()	{	string $clusters[] = `ls -type cluster`;	for ($cluster in $clusters)	{		setAttr ($cluster + ".relative") 1;	}	}global proc clustersEnvelope (string $attribute){	string $clusters[] =  `ls -fl -sl`;	int $test = 0;		for ($cluster in $clusters)	{		string $clusterHandles[] = `listConnections -type cluster $cluster`;		$test = catchQuiet (`connectAttr -f $attribute ($clusterHandles[0] + ".envelope")`);				if($test == 1)		{			print ($clusterHandles[0] + ".envelope is already connected."); 		}					else		{			connectAttr -f $attribute ($clusterHandles[0] + ".envelope");		}	}}global proc matchPosition (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $pos[] = `xform -q -ws -rp $source`;		move -a -ws $pos[0] $pos[1] $pos[2] $target  ;		select $target;		//smartFreezeTransform;}global proc matchOrient (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $orientation[] = `xform -q -ws -ro $source`;		rotate -ws $orientation[0] $orientation[1] $orientation[2] $target;		select $target;		smartFreezeTransform;}global proc matchSpace (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $rot[] = `xform -q -ws -rotation $source`;	float $pos[] = `xform -q -ws -rp $source`;		move -a -ws $pos[0] $pos[1] $pos[2] ($target + ".scalePivot") ($target + ".rotatePivot") ;		string $name = ($target + "_Group");		string $group = `group -em -n $name`;		move -a -ws $pos[0] $pos[1] $pos[2] $group;	rotate -a -ws $rot[0] $rot[1] $rot[2];		parent $target $group;		smartFreezeTransform;	}global proc matchPivot (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $pos[] = `xform -q -ws -rp $source`;		move -a -ws $pos[0] $pos[1] $pos[2] ($target + ".scalePivot") ($target + ".rotatePivot") ;}global proc matchPivotForClusters (){	string $sel[] = `ls -sl`;	for ($obj in $sel)	{		string $clusterTransform[] = `connectionInfo -destinationFromSource ($obj + ".translateX")`;				string $buffer[];		tokenize $clusterTransform[0] "." $buffer;				select $obj;		select -add $buffer[0];				matchPivot;	}}global proc connectTranslateOffset (string $operation, string $offsetDestination){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];	float $offset[];		if ($offsetDestination == "source")	{		$offset[0] = `getAttr ($source + ".translateX")`;		$offset[1] = `getAttr ($source + ".translateY")`;		$offset[2] = `getAttr ($source + ".translateZ")`;	}		else if ($offsetDestination == "target")	{		$offset[0] = `getAttr ($target + ".translateX")`;		$offset[1] = `getAttr ($target + ".translateY")`;		$offset[2] = `getAttr ($target + ".translateZ")`;	}		createNode plusMinusAverage -n ($target + "_TranslateX_PM");		connectAttr -f ($source + ".translateX") ($target + "_TranslateX_PM.input1D[0]");	setAttr ($target + "_TranslateX_PM.input1D[1]") $offset[0];		createNode plusMinusAverage -n ($target + "_TranslateY_PM");		connectAttr -f ($source + ".translateY") ($target + "_TranslateY_PM.input1D[0]");	setAttr ($target + "_TranslateY_PM.input1D[1]") $offset[1];		createNode plusMinusAverage -n ($target + "_TranslateZ_PM");		connectAttr -f ($source + ".translateZ") ($target + "_TranslateZ_PM.input1D[0]");	setAttr ($target + "_TranslateZ_PM.input1D[1]") $offset[2];		connectAttr -f ($target + "_TranslateX_PM.output1D") ($target + ".translateX");	connectAttr -f ($target + "_TranslateY_PM.output1D") ($target + ".translateY");	connectAttr -f ($target + "_TranslateZ_PM.output1D") ($target + ".translateZ");		if($operation == "add")	{		setAttr ($target + "_TranslateX_PM.operation") 1;		setAttr ($target + "_TranslateY_PM.operation") 1;		setAttr ($target + "_TranslateZ_PM.operation") 1;			}		if($operation == "subtract")	{		setAttr ($target + "_TranslateX_PM.operation") 2;		setAttr ($target + "_TranslateY_PM.operation") 2;		setAttr ($target + "_TranslateZ_PM.operation") 2;	}	}global proc connectRotateOffset (string $operation, string $offsetDestination){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];	float $offset[];			if ($offsetDestination == "source")	{		$offset[0] = `getAttr ($source + ".rotateX")`;		$offset[1] = `getAttr ($source + ".rotateY")`;		$offset[2] = `getAttr ($source + ".rotateZ")`;	}		else if ($offsetDestination == "target")	{		$offset[0] = `getAttr ($target + ".rotateX")`;		$offset[1] = `getAttr ($target + ".rotateY")`;		$offset[2] = `getAttr ($target + ".rotateZ")`;	}			createNode plusMinusAverage -n ($target + "_RotateX_PM");		connectAttr -f ($source + ".rotateX") ($target + "_RotateX_PM.input1D[0]");	setAttr ($target + "_RotateX_PM.input1D[1]") $offset[0];		createNode plusMinusAverage -n ($target + "_RotateY_PM");		connectAttr -f ($source + ".rotateY") ($target + "_RotateY_PM.input1D[0]");	setAttr ($target + "_RotateY_PM.input1D[1]") $offset[1];		createNode plusMinusAverage -n ($target + "_RotateZ_PM");		connectAttr -f ($source + ".rotateZ") ($target + "_RotateZ_PM.input1D[0]");	setAttr ($target + "_RotateZ_PM.input1D[1]") $offset[2];		connectAttr -f ($target + "_RotateX_PM.output1D") ($target + ".rotateX");	connectAttr -f ($target + "_RotateY_PM.output1D") ($target + ".rotateY");	connectAttr -f ($target + "_RotateZ_PM.output1D") ($target + ".rotateZ");		if($operation == "add")	{		setAttr ($target + "_RotateX_PM.operation") 1;		setAttr ($target + "_RotateY_PM.operation") 1;		setAttr ($target + "_RotateZ_PM.operation") 1;			}		if($operation == "subtract")	{		setAttr ($target + "_RotateX_PM.operation") 2;		setAttr ($target + "_RotateY_PM.operation") 2;		setAttr ($target + "_RotateZ_PM.operation") 2;	}	}global proc connectAutoMD (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		if(`size($sel)` == 2)	{			createNode multiplyDivide -n ($target + "_MD");		createNode reverse -n ($target + "_Reverse");				addAttr -ln "AutoRotate"  -at double  -min 0 -max 1 -dv 1 $source;		setAttr -e-keyable true ($source + ".AutoRotate");				connectAttr -f ($source + ".AutoRotate") ($target + "_Reverse.inputX");		connectAttr -f ($target + "_Reverse.outputX") ($target + ".visibility");				connectAttr -f ($source + ".rotateX") ($target + "_MD.input1X");		connectAttr -f ($source + ".rotateY") ($target + "_MD.input1Y");		connectAttr -f ($source + ".rotateZ") ($target + "_MD.input1Z");				connectAttr -f ($source + ".AutoRotate") ($target + "_MD.input2X");		connectAttr -f ($source + ".AutoRotate") ($target + "_MD.input2Y");		connectAttr -f ($source + ".AutoRotate") ($target + "_MD.input2Z");				connectAttr -f ($target + "_MD.outputX")  ($target + ".rotateX");		connectAttr -f ($target + "_MD.outputY")  ($target + ".rotateY");		connectAttr -f ($target + "_MD.outputZ")  ($target + ".rotateZ");		}	}global proc connectMultiAutoMD (string $sourceObj){	string $sel[] = `ls -sl`;	string $source = $sourceObj;	addAttr -ln "AutoRotate"  -at double  -min 0 -max 1 -dv 1 $source;	setAttr -e-keyable true ($source + ".AutoRotate");		for ($obj in $sel)	{		createNode multiplyDivide -n ($obj + "_MD");		createNode reverse -n ($obj + "_Reverse");				connectAttr -f ($source + ".AutoRotate") ($obj + "_Reverse.inputX");		connectAttr -f ($obj + "_Reverse.outputX") ($obj+ ".visibility");				connectAttr -f ($source + ".rotateX") ($obj + "_MD.input1X");		connectAttr -f ($source + ".rotateY") ($obj + "_MD.input1Y");		connectAttr -f ($source + ".rotateZ") ($obj + "_MD.input1Z");				connectAttr -f ($source + ".AutoRotate") ($obj + "_MD.input2X");		connectAttr -f ($source + ".AutoRotate") ($obj + "_MD.input2Y");		connectAttr -f ($source + ".AutoRotate") ($obj + "_MD.input2Z");				connectAttr -f ($obj + "_MD.outputX")  ($obj + ".rotateX");		connectAttr -f ($obj + "_MD.outputY")  ($obj + ".rotateY");		connectAttr -f ($obj + "_MD.outputZ")  ($obj + ".rotateZ");	}	}global proc connectPivotWithOffset (){		string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $translateValueX = `getAttr ($source + ".translateX")`;	float $translateValueY = `getAttr ($source + ".translateY")`;	float $translateValueZ = `getAttr ($source + ".translateZ")`;		float $pivotValueX = `getAttr ($target + ".rotatePivotX")`;	float $pivotValueY = `getAttr ($target + ".rotatePivotY")`;	float $pivotValueZ = `getAttr ($target + ".rotatePivotZ")`;		float $translateXOffset = $pivotValueX - $translateValueX ;	float $translateYOffset = $pivotValueY - $translateValueY;	float $translateZOffset = $pivotValueZ - $translateValueZ;		createNode plusMinusAverage -n ($target + "_PivotX_PM");		connectAttr -f ($source + ".translateX") ($target + "_PivotX_PM.input1D[0]");	setAttr ($target + "_PivotX_PM.input1D[1]") $translateXOffset;		createNode plusMinusAverage -n ($target + "_PivotY_PM");		connectAttr -f ($source + ".translateY") ($target + "_PivotY_PM.input1D[0]");	setAttr ($target + "_PivotY_PM.input1D[1]") $translateYOffset;		createNode plusMinusAverage -n ($target + "_PivotZ_PM");		connectAttr -f ($source + ".translateZ") ($target + "_PivotZ_PM.input1D[0]");	setAttr ($target + "_PivotZ_PM.input1D[1]") $translateZOffset;		connectAttr -f ($target + "_PivotX_PM.output1D") ($target + ".rotatePivotX");	connectAttr -f ($target + "_PivotY_PM.output1D") ($target + ".rotatePivotY");	connectAttr -f ($target + "_PivotZ_PM.output1D") ($target + ".rotatePivotZ");		connectAttr -f ($target + "_PivotX_PM.output1D") ($target + ".scalePivotX");	connectAttr -f ($target + "_PivotY_PM.output1D") ($target + ".scalePivotY");	connectAttr -f ($target + "_PivotZ_PM.output1D") ($target + ".scalePivotZ");	}global proc smartFreezeTransform (){	string $sel[] = `ls -sl`;		for ($obj in $sel)	{		if( !`getAttr -l ($obj + ".tx")` && !`getAttr -l ($obj + ".ty")` && !`getAttr -l ($obj + ".tz")` &&		    !`connectionInfo -id ($obj + ".tx")` && !`connectionInfo -id ($obj + ".ty")` && !`connectionInfo -id ($obj + ".tz")` )		{			makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $obj;		}		if( !`getAttr -l ($obj + ".rx")` && !`getAttr -l ($obj + ".ry")` && !`getAttr -l ($obj + ".rz")` &&		    !`connectionInfo -id ($obj + ".rx")` && !`connectionInfo -id ($obj + ".ry")` && !`connectionInfo -id ($obj + ".rz")` )		{			makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $obj;		}		if( !`getAttr -l ($obj + ".sx")` && !`getAttr -l ($obj + ".sy")` && !`getAttr -l ($obj + ".sz")` &&		    !`connectionInfo -id ($obj + ".sx")` && !`connectionInfo -id ($obj + ".sy")` && !`connectionInfo -id ($obj + ".sz")` )		{			makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $obj;		}					}}global proc openJointOrientAttrs (){	string $joints[] = `ls -type joint`;		for ($joint in $joints)	{		setAttr -k off ($joint + ".rotateAxisX");		setAttr -k off ($joint + ".rotateAxisY");		setAttr -k off ($joint + ".rotateAxisZ");				setAttr -k on ($joint + ".jointOrientX");		setAttr -k on ($joint + ".jointOrientY");		setAttr -k on ($joint + ".jointOrientZ");			}}global proc openOrientAttr (){	string $sel[] = `ls -sl`;		for ($obj in $sel)	{		setAttr -k on ($obj + ".rotateAxisX");		setAttr -k on ($obj + ".rotateAxisY");		setAttr -k on ($obj + ".rotateAxisZ");					}}global proc transformDisplayJoints (){	string $joints[] = `ls -type joint`;	select $joints;	toggle -localAxis;}global proc deleteSmoothNodes (){	string $smoothNodes[] = `ls -type polySmoothFace`;		for($smoothNode in $smoothNodes)	{		delete $smoothNode;	}}global proc OhShiznit (){	select -cl;	string $objs[] = `ls -dep`;	for ($obj in $objs)	{		string $list = `match "pasted__" $obj`;			if($list == "pasted__")		{			delete $obj; 		}	}}global proc findDuplicateName (){	select -cl;	string $objs[] = `ls -dep`;	for ($obj in $objs)	{		string $list = `match "|" $obj`;			if($list == "|")		{			print ($obj +"\n");		}	}}global proc clusterControls (string $shape){	string $clusters[] = `ls -sl`;		for ($cluster in $clusters)	{		string $name = `substitute "CL" $cluster "Ctrl"`;				eval($shape + " -r 0.25 -n " + $name);		pointConstraint -n ($name + "constraint") -tl $cluster $name;		delete ($name + "constraint");					setAttr ($name + "Shape.overrideEnabled") 1;		setAttr ($name + "Shape.overrideColor") 18;		setAttr -lock true -keyable false -channelBox false  ($name  + ".visibility");		makeIdentity -apply true -translate true -rotate true -scale true $name;					connectAttr -f ($name + ".translateX") ($cluster + ".translateX");		connectAttr -f ($name + ".translateY") ($cluster + ".translateY");		connectAttr -f ($name + ".translateZ") ($cluster + ".translateZ");					connectAttr -f ($name + ".rotateX") ($cluster + ".rotateX");		connectAttr -f ($name + ".rotateY") ($cluster + ".rotateY");		connectAttr -f ($name + ".rotateZ") ($cluster + ".rotateZ");					connectAttr -f ($name + ".scaleX") ($cluster + ".scaleX");		connectAttr -f ($name + ".scaleY") ($cluster + ".scaleY");		connectAttr -f ($name + ".scaleZ") ($cluster + ".scaleZ");					group -n ($name + "_Group") -r $name ;				}}global proc massConnect (string $attrFrom, string $attrTo){	string $sel[] = `ls -sl`;		for ($obj in $sel)	{		string $shape[] = `listRelatives -type shape`;				if(`nodeType $shape[0]` == "clusterHandle")		{			string $clusterHandle[] = `connectionInfo -destinationFromSource ($obj + ".worldMatrix[0]")`;			string $buffer[];			tokenize $clusterHandle[0] "." $buffer;						if(!`isConnected $attrFrom  (($buffer[0] + ".") + $attrTo)`)				connectAttr -f $attrFrom  (($buffer[0] + ".") + $attrTo);		}				else		{			if(!`isConnected $attrFrom  (($obj + ".")+  $attrTo)`)				connectAttr -f $attrFrom (($obj + ".")+  $attrTo);		}	}	}global proc quickConnect (int $translate,int $rotate, int $scale, int $pivot){	string $sel[] = `ls -fl -sl`;	string $source = $sel[0];	string $target = $sel[1];		if ($translate == 1)	{		connectAttr -f ($source + ".translateX") ($target + ".translateX");		connectAttr -f ($source + ".translateY") ($target + ".translateY");		connectAttr -f ($source + ".translateZ") ($target + ".translateZ");	}		if($rotate == 1)	{			connectAttr -f ($source + ".rotateX") ($target + ".rotateX");		connectAttr -f ($source + ".rotateY") ($target + ".rotateY");		connectAttr -f ($source + ".rotateZ") ($target + ".rotateZ");	}		if($scale == 1)		{		connectAttr -f ($source + ".scaleX") ($target + ".scaleX");		connectAttr -f ($source + ".scaleY") ($target + ".scaleY");		connectAttr -f ($source + ".scaleZ") ($target + ".scaleZ");	}		if ($pivot == 1)	{				float $scalePivot[] = `xform -q -ws -sp $source`;		float $rotatePivot[] = `xform -q -ws -rp $source`;				move -a -ws $rotatePivot[0] $rotatePivot[1] $rotatePivot[2] ($target + ".scalePivot") ($target + ".rotatePivot") ;	} }  global proc quickConnectSpecific (int $translateX, int $translateY, int $translateZ, int $rotateX, int $rotateY, int $rotateZ, int $scaleX, int $scaleY,int $scaleZ, int $pivot){	string $sel[] = `ls -fl -sl`;	string $source = $sel[0];	string $target = $sel[1];		if ($translateX == 1)	{		connectAttr -f ($source + ".translateX") ($target + ".translateX");	}	if ($translateY == 1)	{		connectAttr -f ($source + ".translateY") ($target + ".translateY");	}	if ($translateZ == 1)	{		connectAttr -f ($source + ".translateZ") ($target + ".translateZ");	}		if($rotateX == 1)	{			connectAttr -f ($source + ".rotateX") ($target + ".rotateX");	}	if($rotateY == 1)	{			connectAttr -f ($source + ".rotateY") ($target + ".rotateY");	}	if($rotateZ == 1)	{			connectAttr -f ($source + ".rotateZ") ($target + ".rotateZ");	}		if($scaleX == 1)		{		connectAttr -f ($source + ".scaleX") ($target + ".scaleX");	}	if($scaleY == 1)		{		connectAttr -f ($source + ".scaleY") ($target + ".scaleY");	}	if($scaleZ == 1)		{		connectAttr -f ($source + ".scaleZ") ($target + ".scaleZ");	}		if ($pivot == 1)	{				float $scalePivot[] = `xform -q -ws -sp $source`;		float $rotatePivot[] = `xform -q -ws -rp $source`;				move -a -ws $rotatePivot[0] $rotatePivot[1] $rotatePivot[2] ($target + ".scalePivot") ($target + ".rotatePivot") ;	} }global proc clusterPoints (){	string $points[] = `ls -fl -sl`;		for ($point in $points)	{		int $i = 1;		string $cluster = `cluster -wn $point ("cluster" + $i)`;		$i++;	}}global proc deleteInputConstraints (){	string $sel[] = `ls -fl -sl`;		for ($obj in $sel)		{			string $parentConstraints[] = `listConnections -t parentConstraint $obj `;			string $pointConstraints[] = `listConnections -t pointConstraint $obj `;			string $orientConstraints[] = `listConnections -t orientConstraint $obj `;			string $aimConstraints[] = `listConnections -t aimConstraint $obj `;			string $scaleConstraints[]= `listConnections -t scaleConstraint $obj `;						string $constraints01[] = stringArrayCatenate($parentConstraints, $pointConstraints);			string $constraints02[] = stringArrayCatenate($orientConstraints,$aimConstraints);			string $constraint03[] = stringArrayCatenate($constraints01,$constraints02);						string $constraints[] = stringArrayCatenate($constraint03,$scaleConstraints);						for ($constraint in $constraints)			{				if(`connectionInfo -sfd ($obj + ".tx")` == ($constraint + ".constraintTranslateX") || `connectionInfo -sfd ($obj + ".ty")` == ($constraint + ".constraintTranslateY") || `connectionInfo -sfd ($obj + ".tz")` == ($constraint + ".constraintTranslateZ") ||				   `connectionInfo -sfd ($obj + ".rx")` == ($constraint + ".constraintRotateX") || `connectionInfo -sfd ($obj + ".ry")` == ($constraint + ".constraintRotateY") || `connectionInfo -sfd ($obj + ".rz")` == ($constraint + ".constraintRotateZ") ||				   `connectionInfo -sfd ($obj + ".sx")` == ($constraint + ".constraintScaleX") || `connectionInfo -sfd ($obj + ".sy")` == ($constraint + ".constraintScaleY") || `connectionInfo -sfd ($obj + ".sz")` == ($constraint + ".constraintScaleZ"))				 				{					delete $constraint;				}			}		}}global proc moveShapes (){	string $sel[] = `ls -sl`;	string $target = $sel[0];	string $source = $sel[1];	string $group = `group -em`;	string $constraint[] = `parentConstraint -tl $source $group`;	delete $constraint[0];	parent $target $group;	select $target;	smartFreezeTransform;		string $shapes[] = `listRelatives -type shape $target`;	for ($shape in $shapes)	{		string $name = ($source + "Shape");		parent -r -s $shape $source;		rename $shape $name;	}		delete $group;}global proc replaceShapes (){	string $sel[] = `ls -sl`;	string $target = $sel[0];	string $source = $sel[1];	string $group = `group -em`;	string $constraint[] = `parentConstraint -tl $source $group`;	delete $constraint[0];	parent $target $group;	select $target;	smartFreezeTransform;		string $targetShapes[] = `listRelatives -type shape $target`;	string $sourceShapes[] = `listRelatives -type shape $source`;	delete $sourceShapes;	for ($shape in $targetShapes)	{		parent -r -s $shape $source;	}		delete $group;}global proc fourArrowCurve (){	curve -d 1 -p 0 0 0 -p 0 0 -2 -p -1 0 -2 -p 1 0 -5 -p 3 0 -2 -p 2 0 -2 -p 2 0 0 	-p 4 0 0 -p 4 0 -1 -p 7 0 1 -p 4 0 3 -p 4 0 2 -p 2 0 2 -p 2 0 4 -p 3 0 4 -p 1 0 7 	-p -1 0 4 -p 0 0 4 -p 0 0 2 -p -2 0 2 -p -2 0 3 -p -5 0 1 -p -2 0 -1 -p -2 0 0 	-p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -	k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;}global proc singleArrow (){	curve -d 1 -p -1 0 0 -p 1 0 0 -p 1 0 3 -p 2 0 3 -p 0 0 6 -p -2 0 3 -p -1 0 3 	-p -1 0 0 -p 1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 ;}global proc cubeCurve (){	curve -d 1 -p 0 0 0 -p 0 2 0 -p 2 2 0 -p 2 0 0 -p 0 0 0 -p 0 0 -2 -p 0 2 -2 -p 0 2 0 -p 0 0 0 -p 2 0 0 	-p 2 2 0 -p 0 2 0 -p 0 0 0 -p 0 0 0 -p 0 0 0 -p 0 0 0 -p 0 0 -2 -p 2 0 -2 -p 2 0 0 -p 2 2 0 -p 2 2 -2 -p 2 0 -2 	-p 2 0 0 -p 2 0 -2 -p 2 2 -2 -p 0 2 -2 -p 0 0 -2 -p 2 0 -2 -p 0 0 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 	-k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 	-k 25 -k 26 -k 27 -k 28 -k 29 ;}global proc weightedConstraint (){	string $sel[] = `ls -fl -sl`;	string $points[];	$points[0] = $sel[0];	string $ctrl = $sel[1];		string $skinCluster = `getSkinClusterFromPoint $points[0]`;	string $joints[] = `getInfluencesFromPoints $points`;		string $constraint[] = `parentConstraint -mo $joints $ctrl`;	string $targetList[] = `parentConstraint -q -tl $constraint[0]`;	setAttr ($constraint[0] + ".interpType") 0;		int $t = `size($joints)`;		for ($i = 0; $i < $t; $i++)	{		float $value = `skinPercent -transform $joints[$i] -query $skinCluster $points[0]`;		parentConstraint -e -w $value $targetList[$i] $constraint[0];	}	}global proc weightedConstraintInclude (string $target){	string $sel[] = `ls -fl -sl`;	string $points[];	$points[0] = $sel[0];	string $ctrl = $sel[1];		string $skinCluster = `getSkinClusterFromPoint $points[0]`;	string $joints[] = `getInfluencesFromPoints $points`;	string $targets[];	$targets[0] = $target;	string $includeTargets[] = stringArrayCatenate($joints, $targets);		string $constraint[] = `parentConstraint -mo $includeTargets $ctrl`;	string $targetList[] = `parentConstraint -q -tl $constraint[0]`;	setAttr ($constraint[0] + ".interpType") 0;		int $t = `size($joints)`;		for ($i = 0; $i < $t; $i++)	{		float $value = `skinPercent -transform $joints[$i] -query $skinCluster $points[0]`;		parentConstraint -e -w $value $targetList[$i] $constraint[0];	}	}global proc weightedBlendShape (string $influence, string $blendShape, int $blendTarget){	string $verts[] = `ls -fl -sl`;	string $skincluster = `getSkinClusterFromPoint $verts[0]`;		for ($vert in $verts)	{		float $value = `skinPercent -transform $influence -query $skincluster $vert`;				string $buffer[];		tokenize $vert "[]" $buffer;		string $vertNum = $buffer[1];				setAttr ((((($blendShape + ".inputTarget[") + $blendTarget) + "].inputTargetGroup[0].targetWeights[") + $vertNum) + "]") $value;	}		}global proc quickAimConstaint (){	string $sel[] = `ls -sl`;	string $source = $sel[0];	string $target = $sel[1];		float $aimVecPos[] = `xform -q -ws -rp $target`;		string $upVector[] = `spaceLocator -n ($target + "_Aim_UpVector_Loc")`;	move -a -ws $aimVecPos[0] $aimVecPos[1] $aimVecPos[2] $upVector[0];		move -r -ws 0 15 0 $upVector[0];		parentConstraint -mo $source $upVector[0];		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVector[0] $source $target;	}global proc latticeGroup (){	string $lattice[] = `lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;	string $group = `group $lattice`;}global proc addGeoDeformerSet (){	string $sel[] = `ls -sl`;	string $geo = $sel[1];	string $defromer = $sel[0];		deformer -e -g $geo $defromer;}global proc connectSmooth (string $attr){	string $smoothNodes[] = `ls -type polySmoothFace`;		for ($node in $smoothNodes)	{		connectAttr -f $attr ($node + ".divisions");	}}global proc findCenter (){	string $sel[] =  `ls -fl -sl`;		if(`size($sel)` > 1)	{		string $verts[] =  `polyListComponentConversion -tv $sel`;		select $verts;		string $indVerts[] = `ls -fl -sl`;		int $numVerts = `size($indVerts)`;		string $locator[] = `spaceLocator` ;		float $Xpos = 0;		float $Ypos = 0;		float $Zpos = 0;		//find TX		 		for($vert in $indVerts)		{			float $pos[] = `xform -q -ws -t $vert`;			$Xpos += $pos[0]; 		}		float $aveXpos = $Xpos / $numVerts; 		//find TY		 		for($vert in $indVerts)		{			float $pos[] = `xform -q -ws -t $vert`;			$Ypos += $pos[1]; 		}		float $aveYpos = $Ypos / $numVerts; 		//find TZ		 		for($vert in $indVerts)		{			float $pos[] = `xform -q -ws -t $vert`;			$Zpos += $pos[2]; 		}		float $aveZpos = $Zpos / $numVerts; 		move -a -ws $aveXpos $aveYpos $aveZpos $locator;	}}global proc averageDist (string $attr){	string $sel[] = `ls -sl`;	float $value = 0;	int $numSel = `size($sel)`;		for ($obj in $sel)	{		float $currentValue = `getAttr ($obj + $attr)`;		$value += $currentValue;	}		float $averageValue = $value / $numSel;		for ($obj in $sel)	{		setAttr ($obj + $attr) $averageValue;	}}global proc singleJointStretch (){	string $sel[] = `ls -sl`;	string $startJoint = $sel[0];	string $endJoint = $sel[1];	string $control = $sel[2];	string $startNull = `group -em`;			float $startJointPos[] = `xform -q -ws -translation $startJoint`;	move -a $startJointPos[0] $startJointPos[1] $startJointPos[2] $startNull;	float $startJointRot[] = `xform -q -ws -rotation $startJoint`;	rotate -a $startJointRot[0] $startJointRot[1] $startJointRot[2] $startNull;	string $endNull = `group -em`;		float $endJointPos[] = `xform -q -ws -translation $endJoint`;	move $endJointPos[0] $endJointPos[1] $endJointPos[2] $endNull;	float $endJointRot[] = `xform -q -ws -rotation $endJoint`;	rotate $endJointRot[0] $endJointRot[1] $endJointRot[2] $endNull;	parent $endNull $startNull;		string $locator[] = `spaceLocator`;	move $endJointPos[0] $endJointPos[1] $endJointPos[2] $locator[0];	$aimConstraint = `aimConstraint -aim 1 0 0 $locator[0] $startNull `;	$pointConstraintStartNull = `pointConstraint -mo $locator[0] $endNull`;	$pointConstraintEndNull = `pointConstraint -mo $startJoint $startNull`;	$pointConstraintLoc = `pointConstraint  -mo  $control $locator[0]`;	connectAttr -f  ($endNull + ".tx") ($endJoint + ".tx");	rename $startNull ($startJoint + "Start_Null");	rename $endNull ($endJoint + "End_Null");	rename $locator ($endJoint + "End_Stretch_Loc");		}global proc rivetRibbonIK (string $ribbon, int $spanNum){	float $doubleSpan = $spanNum * 2.0;	float $increment = 1.0/ $spanNum;	float $spanMid = 1.0 / $doubleSpan;		float $currentValue = $spanMid;	for ($i = 0; $i < $spanNum ; $i++)	{				select ((($ribbon + ".uv[0.5][" ) + $currentValue) + "]") ;		rivet;				//print ($currentValue + "\n");				$currentValue += $increment;		}}global proc createJointCurve (string $name){    string $startJoint[] = `ls -sl`;    string $childJoints[] = `listRelatives -type joint -ad`;    string $sortedChildJoints[] = sort($childJoints);    int $numJoints = size($childJoints);    float $startJointPos[] = `xform -q -ws -t $startJoint`;    curve -d 3 -ws -p $startJointPos[0] $startJointPos[1] $startJointPos[2] -n ($name + "_Curve");     for($i = 0; $i < $numJoints; $i++)    {        float $jointPos[] = `xform -q -ws -t $sortedChildJoints[$i]`;        curve -d 3 -ws -a -p  $jointPos[0] $jointPos[1] $jointPos[2] ($name + "_Curve");    }    }global proc curveRebuild (string $curve, int $spans){	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 1 -tol 0.01 $curve;	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s $spans -d 3 -tol 0.01 $curve;}global proc jointsOnCurveCVs (string $curve, string $name){	select $curve;	selectCurveCV("all");		string $CVs[] = `ls -fl -sl`;	int $numCVs = `size($CVs)`;		for ($i = 0; $i < $numCVs; $i++)	{		float $pos[] = `xform -q -ws -t $CVs[$i]`;		joint -p $pos[0] $pos[1] $pos[2] -n ((($name + "_0" ) + $i) + "_Jnt");		select -cl;	}}global proc jointsOnCurvePoints (string $curve, int $numJoints, string $up, string $frontAxis, string $name){				string $curveShape[] = `listRelatives -type shape $curve`;		int $iterator = $numJoints + 1;	int $normalValueIt = $numJoints - 1;	float $normalValue = 1.0 / $normalValueIt ;	float $UValue = 0;		for ($i = 1; $i < $iterator; $i++)	{				string $motionPathNode = `createNode motionPath -name ($name + "_motionPath")`;		string $locator[] = `spaceLocator -n ($name + "_Loc") -p 0 0 0`;				connectAttr -f ($curveShape[0] + ".worldSpace[0]") ($name + "_motionPath.geometryPath");				connectAttr -f ($motionPathNode + ".xCoordinate") ($locator[0] + ".tx");		connectAttr -f ($motionPathNode + ".yCoordinate") ($locator[0] + ".ty");		connectAttr -f ($motionPathNode + ".zCoordinate") ($locator[0] + ".tz");				connectAttr -f ($motionPathNode + ".rx") ($locator[0] + ".rx");		connectAttr -f ($motionPathNode + ".ry") ($locator[0] + ".ry");		connectAttr -f ($motionPathNode + ".rz") ($locator[0] + ".rz");				setAttr ($motionPathNode + ".fractionMode") 1;		setAttr ($motionPathNode + ".follow") 1;		setAttr ($motionPathNode + ".frontAxis") 0;		setAttr ($motionPathNode + ".upAxis") 1;		setAttr ($motionPathNode + ".worldUpType") 0;		setAttr ($motionPathNode + ".uValue") $UValue;		$UValue += $normalValue;				if($up == "X")				{			setAttr ($motionPathNode + ".upAxis") 0;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-X")				{			setAttr ($motionPathNode + ".upAxis") 0;			setAttr ($motionPathNode + ".inverseUp") 1;		}								if($up == "Y")				{			setAttr ($motionPathNode + ".upAxis") 1;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-Y")				{			setAttr ($motionPathNode + ".upAxis") 1;			setAttr ($motionPathNode + ".inverseUp") 1;		}				if($up == "Z")				{			setAttr ($motionPathNode + ".upAxis") 2;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-Z")				{			setAttr ($motionPathNode + ".upAxis") 2;			setAttr ($motionPathNode + ".inverseUp") 1;		}				if($frontAxis == "X")		{			setAttr ($motionPathNode + ".frontAxis") 0;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-X")		{			setAttr ($motionPathNode + ".frontAxis") 0;			setAttr ($motionPathNode + ".inverseFront") 1;		}				if($frontAxis == "Y")		{			setAttr ($motionPathNode + ".frontAxis") 1;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-Y")		{			setAttr ($motionPathNode + ".frontAxis") 1;			setAttr ($motionPathNode + ".inverseFront") 1;		}				if($frontAxis == "Z")		{			setAttr ($motionPathNode + ".frontAxis") 2;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-Z")		{			setAttr ($motionPathNode + ".frontAxis") 2;			setAttr ($motionPathNode + ".inverseFront") 1;		}								float $pos[] = `xform -q -ws -t $locator[0]`;		float $rot[] = `xform -q -ws -rotation $locator[0]`;		select -cl;		string $joint = `joint -p $pos[0] $pos[1] $pos[2] -n ((($name + "_0" ) + $i) + "_Jnt")`;		rotate -ws $rot[0] $rot[1] $rot[2] $joint;		smartFreezeTransform;					select -cl;				delete $motionPathNode;		delete ($name + "_Loc");			}}global proc AimOrientJoints (string $up){	string $sel[] = `ls -sl`;	int $numJoints = `size($sel)`;		for($i = 0; $i < $numJoints; $i++)	{		int $nextJoint = $i - 1;				if ($nextJoint > -1)		{					if($up == "Y")			{				if(`objExists $sel[$nextJoint]`)				{					string $aimConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" $sel[$i] $sel[$nextJoint]`;					delete $aimConstraint[0];				}			}							if($up == "-Y")			{				if(`objExists $sel[$nextJoint]`)				{					string $aimConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "scene" $sel[$i] $sel[$nextJoint]`;					delete $aimConstraint[0];				}			}							if($up == "Z")			{				if(`objExists $sel[$nextJoint]`)				{					string $aimConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "scene" $sel[$i] $sel[$nextJoint]`;					delete $aimConstraint[0];				}			}							if($up == "-Z")			{				if(`objExists $sel[$nextJoint]`)				{					string $aimConstraint[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "scene" $sel[$i] $sel[$nextJoint]`;					delete $aimConstraint[0];				}			}				}	}	}global proc pointOnCurveLocatorsBSB (string $name, int $numLocs,string $frontAxis, string $up){	//originally written by Clayton		int $numberOfPoints = $numLocs;	string $partName = $name;	string $sel[] = `ls -sl`;	string $curve = $sel[0];	string $curveShape[] = `listRelatives -shapes $curve`;	string $allLocators[];	clear $allLocators;		float $normalValue = 1.0 / $numLocs;	float $UValue = 0;	for ($i=0; $i <= $numberOfPoints; $i++)	{		string $zero = "0";		if ($i > 8)			$zero = "";						string $locator[] = `spaceLocator -n ($partName + "_" + $zero + ($i + 1) + "_Loc") -p 0 0 0`;		$allLocators[$i] = $locator[0];						string $motionPathNode = `createNode motionPath -name ($partName + "_" + $zero + ($i + 1) + "_motionPath")`;		setAttr ($motionPathNode + ".fractionMode") 1;		setAttr ($motionPathNode + ".follow") 1;		setAttr ($motionPathNode + ".frontAxis") 0;		setAttr ($motionPathNode + ".upAxis") 1;		setAttr ($motionPathNode + ".worldUpType") 1;		setAttr ($motionPathNode + ".worldUpVector") 0 1 0;				connectAttr -f ($curveShape[0] + ".worldSpace[0]") ($motionPathNode + ".geometryPath");		//connectAttr -f ($motionPathNode + ".rx") ($locator[0] + ".rx");		//connectAttr -f ($motionPathNode + ".ry") ($locator[0] + ".ry");		//connectAttr -f ($motionPathNode + ".rz") ($locator[0] + ".rz");		connectAttr -f ($motionPathNode + ".xCoordinate") ($locator[0] + ".tx");		connectAttr -f ($motionPathNode + ".yCoordinate") ($locator[0] + ".ty");		connectAttr -f ($motionPathNode + ".zCoordinate") ($locator[0] + ".tz");		connectAttr -f ($motionPathNode + ".rotateOrder") ($locator[0] + ".rotateOrder");				if($up == "X")				{			setAttr ($motionPathNode + ".upAxis") 0;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-X")				{			setAttr ($motionPathNode + ".upAxis") 0;			setAttr ($motionPathNode + ".inverseUp") 1;		}								if($up == "Y")				{			setAttr ($motionPathNode + ".upAxis") 1;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-Y")				{			setAttr ($motionPathNode + ".upAxis") 1;			setAttr ($motionPathNode + ".inverseUp") 1;		}				if($up == "Z")				{			setAttr ($motionPathNode + ".upAxis") 2;			setAttr ($motionPathNode + ".inverseUp") 0;		}					if($up == "-Z")				{			setAttr ($motionPathNode + ".upAxis") 2;			setAttr ($motionPathNode + ".inverseUp") 1;		}				if($frontAxis == "X")		{			setAttr ($motionPathNode + ".frontAxis") 0;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-X")		{			setAttr ($motionPathNode + ".frontAxis") 0;			setAttr ($motionPathNode + ".inverseFront") 1;		}				if($frontAxis == "Y")		{			setAttr ($motionPathNode + ".frontAxis") 1;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-Y")		{			setAttr ($motionPathNode + ".frontAxis") 1;			setAttr ($motionPathNode + ".inverseFront") 1;		}				if($frontAxis == "Z")		{			setAttr ($motionPathNode + ".frontAxis") 2;			setAttr ($motionPathNode + ".inverseFront") 0;		}				if($frontAxis == "-Z")		{			setAttr ($motionPathNode + ".frontAxis") 2;			setAttr ($motionPathNode + ".inverseFront") 1;		}		//add "Parameter" attr to locator and connect to motionPath uValue to allow user		//an easy method of positioning locator along curve		addAttr -ln "Parameter"  -at double  -min 0 -max 100 $locator[0];		setAttr -e -keyable true ($locator[0] + ".Parameter");				string $parameterMD = `shadingNode -asUtility multiplyDivide -n ($partName + "_" + $zero + ($i + 1) + "_MD")`;		setAttr ($parameterMD + ".operation") 1;		setAttr ($parameterMD + ".input2X") 1;				connectAttr -f ($locator[0] + ".Parameter") ($parameterMD + ".input1X");		connectAttr -f ($parameterMD + ".outputX") ($motionPathNode + ".uValue");		setAttr ($locator[0] + ".Parameter") $UValue;				$UValue += $normalValue;			}		}global proc twistPointOnCurve (string $name, string $curve, string $twistControl, string $mode){	string $joints[] = sort(`ls -sl`);	int $numJoints = `size($joints)`;		string $curveShape[] = `listRelatives -type shape $curve`; 		string $motionPaths[] = sort(`listConnections -type motionPath $curveShape[0]`);		if($mode == "motionPath")	{		for($i = 0; $i < $numJoints; $i++)		{			string $MDnode = `createNode multiplyDivide -name ((($name + "_0") + $i ) + "_MD")`;			float $MDDen = $numJoints;			float $MDvalue = ($i/$MDDen);						connectAttr -f ($twistControl + ".rotateX") ((($name + "_0") + $i ) + "_MD.input1X");			setAttr ((($name + "_0") + $i ) + "_MD.input2X") $MDvalue ;						connectAttr ((($name + "_0") + $i ) + "_MD.outputX") ($motionPaths[$i] + ".frontTwist");			}	}		if($mode == "joint")	{		for($i = 0; $i < $numJoints; $i++)		{			string $MDnode = `createNode multiplyDivide -name ((($name + "_0") + $i ) + "_MD")`;			float $MDDen = $numJoints;			float $MDvalue = ($i/$MDDen);						connectAttr -f ($twistControl + ".rotateX") ((($name + "_0") + $i ) + "_MD.input1X");			setAttr ((($name + "_0") + $i ) + "_MD.input2X") $MDvalue ;						connectAttr ((($name + "_0") + $i ) + "_MD.outputX") ($joints[$i] + ".rotateX");			}	}}global proc createPivotCtrl (string $name, string $constraintTarget){	string $sel[] = `ls -sl`;	string $ctrl[] = `sphere -n $name`;				float $rotatePivot[] = `xform -q -ws -rp $sel[0]`;	float $pos[] = `xform -q -ws -t $sel[0]`;		string $group = `group -n ($ctrl[0] + "_Group") -r $ctrl[0] `;	move -a -ws $pos[0] $pos[1] $pos[2] $group;		parentConstraint -mo $constraintTarget $group;		createNode plusMinusAverage -n ($name + "_TranslateX_PMA"); 	createNode plusMinusAverage -n ($name + "_TranslateY_PMA"); 	createNode plusMinusAverage -n ($name + "_TranslateZ_PMA"); 		setAttr ($name + "_TranslateX_PMA.input1D[0]") $rotatePivot[0];	setAttr ($name + "_TranslateY_PMA.input1D[0]") $rotatePivot[1];	setAttr ($name + "_TranslateZ_PMA.input1D[0]") $rotatePivot[2];		connectAttr -f ($ctrl[0] + ".translateX")($name + "_TranslateX_PMA.input1D[1]");	connectAttr -f ($ctrl[0] + ".translateY")($name + "_TranslateY_PMA.input1D[1]");	connectAttr -f ($ctrl[0] + ".translateZ")($name + "_TranslateZ_PMA.input1D[1]");	connectAttr -f ($name + "_TranslateX_PMA.output1D") ($sel[0] + ".rotatePivotX");	connectAttr -f ($name + "_TranslateY_PMA.output1D") ($sel[0] + ".rotatePivotY");	connectAttr -f ($name + "_TranslateZ_PMA.output1D") ($sel[0] + ".rotatePivotZ");		connectAttr -f ($name + "_TranslateX_PMA.output1D") ($sel[0] + ".scalePivotX");	connectAttr -f ($name + "_TranslateY_PMA.output1D") ($sel[0] + ".scalePivotY");	connectAttr -f ($name + "_TranslateZ_PMA.output1D") ($sel[0] + ".scalePivotZ");		addAttr -ln "PivotX"  -at double $sel[0];	setAttr -e-keyable true ($sel[0] + ".PivotX");		addAttr -ln "PivotY"  -at double $sel[0];	setAttr -e-keyable true ($sel[0] + ".PivotY");		addAttr -ln "PivotZ"  -at double $sel[0];	setAttr -e-keyable true ($sel[0] + ".PivotZ");		connectAttr -f ($sel[0] + ".PivotX") ($ctrl[0] + ".tx") ;	connectAttr -f ($sel[0] + ".PivotY") ($ctrl[0] + ".ty");	connectAttr -f ($sel[0] + ".PivotZ") ($ctrl[0] + ".tz") ;		setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".tx");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".ty");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".tz");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".rx");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".ry");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".rz");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".sx");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".sy");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".tz");	setAttr -lock true -keyable false -channelBox false ($ctrl[0] + ".v");	}global proc createNodesForTransformBlend (string $attr){	string $buffer[];	$numTokens = `tokenize $attr "." $buffer`;	string $name = ($buffer[1] + "_Blend");		createNode multiplyDivide -n ($name + "_MD");	setAttr ($name + "_MD.input2X") 0.1;		createNode reverse -n ($name + "_Reverse");		connectAttr -f $attr ($name + "_MD.input1X");	connectAttr -f $attr ($name + "_Reverse.inputX");}